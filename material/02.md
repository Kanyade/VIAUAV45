# Chapter 2: Flutter basics

In the previous lecture, we have learned about the history of cross-platform frameworks, Flutter, and Dart, and through some examples we have gained an insight into the Dart programming language. Within this lecture, we will take a more detailed look into Flutter applications.

## Flutter project structure
After creating a new project in either Android Studio or Visual Studio Code, a sample project will be created with the most important files already present, which can be already compiled. Let us take a closer look into the structure of the project.

**Kép a projekt struktúráról, mappák kibontva**
The _android_ and _ios_ folder contains the platform specific Embedder code responsible for running the Flutter Engine. These are regular projects with some Flutter-build specific variables included. If needed, we can use our Android or iOS knowledge to write platform specific functions, which can be called from the dart side with the help of platform channels. Thankfully, most of the needed functionality is also available as an external package on [pub.dev](pub.dev). While these platform channels will not be covered in this course, a detailed tutorial can be found [here](https://flutter.dev/docs/development/platform-integration/platform-channels).

If Web support is enabled, the project will also contain a _web_ folder. Similarly to _android_ and _ios_, this folder contains the Web specific Embedder files. The generated files will already conform to the _Progressive Web App_ specifications. Enabling any other platform (such as Windows) will similarly create a folder for that specific platform.

The _lib_ folder contains every Dart source file for our application. After generating a new project, only one file is created (`main.dart`), however any number of sub-folders and files can be created here. By default, the `main.dart` file is the entry point of our application: this contains the `main()` function, which initializes the environment and starts the application.  While it is possible to specify another file as our main entry point, the Flutter build tool uses `lib/main.dart` as the default path, and so it is recommended that we also use this in our development.

The _test_ folder contains our unit tests, with a sample test already included. This can be easily run from the editor of our choice. Note that while Flutter supports integration tests, these are not included by default, and they are typically placed in the `test_driver` folder. 

While a number of useful files are generated in the root folder (such as the `.gitignore` file to avoid committing unnecessary files into our version control system), the `pubspec.yaml` is the most important file in our project. This file contains a number of important variables, such as:

 - The name and description of our project. (Note that the application name is hard coded into the platform-specific embedders, so changing it here will have no effect on the generated application name).
 - The version code of our application in the format `x.y.z+w`. These values can be set to control the versioning system of the platform specific build system. For example, the part before the `+` sign will be the `versionName` in Android and `CFBundleShortVersionString` in iOS, while the second part will be `versionCode` and `CFBundleVersion` respectively.
 - The selected Dart SDK for our project, usually in a version constraint format.
 - The external dependencies in two separate group: as a general rule `dependencies` cover every dependency which is imported inside the `lib` folder, while `dev_dependencies` are for everything else (such as testing libraries and code generation).
 - Under the `flutter` keyword, every Flutter specific information can be found, such as the path to our asset files.

For versioning, the Dart ecosystem uses [semantic versioning](https://semver.org/spec/v2.0.0-rc.1.html). The version consists of three non-negative integers, separated by dots: the major, the minor and the patch number.
 - The patch number is incremented when a backwards-compatible bugfix is implemented in the library.
 - The minor number is usually incremented when new functionality is added to the library or functions are deprecated in backwards-compatible way. The patch number is reset to zero.
 - The major number is incremented if a backwards-incompatible change is implemented in the library. The other two numbers are reset to zero.

If multiple dependency depends on the same library, only one version can be included so as to not generate conflicting classes between different versions of the same library. Because of this, a dependency version resolution must be made every time a dependency is changed. Luckily, this is already provided within the _dart pub_ tool. Any time we add a dependency, we use constraints to specify which version of a library there is. The following constraints are supported:

 - `any` or omitted: Any version of the library can be used. Not recommended due to sudden breaking changes.
 - `1.2.3`: Locks the dependency to an exact version. This leads to version locking, and can easily result in unsolvable constraints. Not recommended for library developers.
 - `>=, >, <=, <` (traditional syntax): Specify the lower and upper range, inclusive or exclusive. You can combine both of these in a single declaration to specify both.
 - `^1.2.3` (caret syntax): Use any version from the given version up to (but not including) the next major version. This is equivalent to `'>=1.2.3 <2.0.0'`. Because this is only available since Dart 1.8.3, the Dart SDK version should only be specified with the traditional syntax to ensure that older versions of the _pub_ tool do not try to process it.

Generally, we can assume that Dart library developers will use semantic versioning, and so the caret syntax is recommended for general use.
While not recommended, we can also override the dependency version in the `dependency_overrides` part. If any package is included here, *pub* will use that version instead of checking for the constraints. While this can be useful if there are incompatible packages, these can easily introduce compile-time or runtime errors, and so it should be only used if necessary.
Running *pub get* will collect the required dependencies, and for every package choose the highest version available while still fulfilling every constraint. The chosen versions can be seen in `pubspec.lock` .

Dependencies can come from four different sources:

 - SDK: to specify any SDK, or packages shippide within these SDK-s. Currently, only Flutter is supported as an SDK source.
 - Hosted packages: These packages are hosted on [pub.dev](pub.dev) (or on any server providing the same API). This is  recommended, and so is the default.
 - Git packages: If the package is only available from a Git repository, we can provide the path within the `git` keyword. This can be useful if the package is proprietary, since private Git repositories can be used, as long as we can connect to it through SSH.
 - Path packages: These are packages stored in our local environment. In this case, `path` keyword specifies the path of the package. Useful if we are developing a framework in a separate package to our application, which is not hosted anywhere.

During the course, we will be mainly using hosted packages. A detailed description (with examples) for the other types can be found [here](https://dart.dev/tools/pub/dependencies).

Another important part are asset files. These are resources which we don't want to include directly in the Dart code either because of their size (larger JSON object), or due to it being in a binary format (media files). Flutter doesn't differentiate between asset files with the only exception being font files.

Asset files can be placed anywhere inside our project structure. During the application build, every asset file specified by the _pubspec_ file will be placed inside a special asset bundle, which can be read by the application at runtime. We can either add one specific file by specifying the relative path of it, or add every file inside a directory by specifying the relative path to the directory. Note that the build tool only adds files inside the specified folder; files inside sub folders are not considered.

Flutter also supports the notion of _file variants_. If a file is added, the build tool will search for a file with the same name in every sub directory of the folder the file is in. For example, consider the following folder structure (from [flutter.dev](https://flutter.dev/docs/development/ui/assets-and-images)):

```
.../pubspec.yaml
.../graphics/my_icon.png
.../graphics/background.png
.../graphics/dark/background.png
...etc.
```
And the following asset declaration:
```
flutter:
  assets:
    - graphics/background.png
```
In this case, `graphics/background.png` is considered the _main_ asset file, while `/graphics/dark/background.png` is a variant (with the label _dark_) of this file. Currently, variants are only used for choosing a resolution appropriate image, but the development team may extend this to include other features.

Resoultion-aware asset files can be placed inside the _Mx_ variant, where _M_ is a non-negative number (typically _2.0x_ and _3.0x_). Flutter then chooses the variant that is the closest to the [`devicePixelRatio`](https://api.flutter.dev/flutter/dart-ui/Window/devicePixelRatio.html), which is a device-specific ratio between the logical and physical pixels. While this value can be inaccurate, the general principal is that 38 logical pixel should cover 1 centimeter (but, for example, Flutter for Web is hardcoded to use 1.0 for the devicePixelRatio, because the correct sizing is left to the browser).

Custom fonts can also be specified here to be used in our application. However, it is recommended that we use the [`google_fonts`](https://pub.dev/packages/google_fonts) package, which can download any one of over one thousand open-source fonts at runtime. If we have selected the font, we can also download and add it as a normal asset to avoid the delay between starting the application and showing texts with the correct font.

## Flutter UI - basics
Flutter takes inspiration from _React_ in creating the user interface by following a declarative UI design. In the more classical imperative UI (such as Android, iOS), we create the layout when the user navigates to the page, and later, when something changes,  mutate some properties of these views. This separates our code base into two main parts: creating and initializing the layout, and changing the view. Also, we can easily end up in an undefined state (such as a progress bar remaining visible indefinitely when a network call throws an exception).

With declarative UI, we are only concerned _how_ a layout should look and function. For a given application state, we create a blueprint of the UI, while the framework manages the layout, shifting the responsibilities of the developers to the framework.

Layouts are typically defined using some kind of XML variant. In Flutter, the development team decided instead to use Dart for layouts as well. While not ideal, this does come with a number of benefits:

 - The build process becomes easier to manage with only Dart code present.
 - Developers have to only know about Dart.
 - Every Dart language construct can be used while creating the layout (such as `if-else`, `for` loops).
 - Data bindings are unnecessary, since variables are already available from Dart code.
 - Testing a layout becomes the same as unit testing.

In Flutter, the most important superclass is `Widget` (somewhat comparable to `View` in Android and `UIView` in iOS). As defined in the [documentation](https://api.flutter.dev/flutter/widgets/Widget-class.html), "A widget is an immutable description of part of a user interface." Indeed, `Widget` has an `@immutable` annotation, meaning that a warning will be shown if the class has any non-final fields. Because of this, every `Widget` inside the Flutter library is declared with a `const` constructor, and it is also recommended that declare our own widgets with it.

> While a `const` constructor can be used to create a constant object, it can also be used as a regular constructor.

To create complex user interfaces, a `Widget` object can contain other `Widget` object(s). In every Flutter application, there is one root widget, which will specify other widgets to add, creating a tree structure (also called _Widget tree_). Widgets can be categorized based on the number of Widgets it can contain:

- None: These widgets define an explicit user interface element. While some properties may be customizable, these are done through the parameters of the constructor. Examples include `Text`, `Image` and `ProgressIndicator`.
- One (or rarely fixed-amount): These widgets provide some kind of extra functionality to the widgets below it. This can be visible to the user (such as an `ElevatedButton`), or provide data to it's child widget tree (such as `InheritedWidget` or the `Provider` library, shown later). This property is always called `child` (with the exemption of `AnimatedCrossFade`, which has a `firstChild` and `secondChild` property).
- Many: These widgets are typically responsible for managing the positions of the widgets in relation to each other. For example, a `Row` widget will place the widgets in a horizontal line, the `Column` widget will place the widgets in a vertical line, while the `Stack` widget will place the widgets on each other. The property for the widgets is called `children`.

> There are also special Widgets called Slivers. While they also extend from the `Widget` class, they can not be used in places of regular widgets. The rule is: if we have a regular widget, it can be used with the `child` or `children` property, while Slivers can be only used with the `sliver` and `slivers` property. Slivers will be mentioned in a later lecture as they are more complex.

With these in mind, let us take a closer look into a simple Flutter application:

> To enable nullability in Flutter projects, a few extra steps are needed:
>  
>  - Replace the Dart SDK constraint to the following: `sdk: '>=2.12.0-0 <3.0.0'`.
>  - Run `flutter pub get` either from the console, or from the IDE.
>  - If it is enabled, there should be errors in the default project.

[DartPad](https://nullsafety.dartpad.dev/5bf4df8730d32620a955f22c33bd5819)

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp("Hello 1"));
}

class MyApp extends StatelessWidget {
  final String appTitle;
  
  const MyApp(this.appTitle);
  
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
	  title: Text(appTitle),
	),
        body: MyWidget("Hello World!"),
      ),
    );
  }
}

class MyWidget extends StatelessWidget {
  final String description;
  
  const MyWidget(this.description);
  
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            description,
            style: theme.textTheme.headline4,
          ),
          ElevatedButton(
            child: Container(width: 60, child: Text("Press me!")),
            onPressed: (){
              ScaffoldMessenger
                .of(context)
                .showSnackBar(
                  SnackBar(
                    content: Text("Button pressed!"),
                  ),
              );
            },
          ),
        ],
      ),
    );
  }
}
```

As with other Dart application, our Flutter application also starts with the `main` function. Here we call the `runApp()` function, which prepares the widget tree, and attaches the given widget into the root of the tree (in our case, an instance of the `MyApp` widget). After attaching a root Widget, the Flutter framework will attach the widgets of the root widget, then their widgets until there is no widget left. The specific properties and functionalities of these widgets will be explained in the next lecture.

Note that changing the parameter of the `MyApp` widget inside the `main()` function has no effect with hot-reload. Hot-reload marks the root widget for needing a re-build. Because of this, changing the root widget will have no effect: Flutter doesn't run the `main()` function again (since that could re-initialize other important variables), and so doesn't know about the change of the root widget.

There is another way a widget may have child widget(s): through a `builder` callback function. This is either used when we have a potentially infinite number of children widgets (for example, an infinite list), or if the child widget must be able to react to changes, commonly used with animations. For these cases, an optional `child` property is also available to avoid unnecessary widget builds, which will be passed to the callback. For example, let us suppose that we want to create a widget which rotates a child widget. In this case, we could have an animator widget, which periodically calls a callback function to create a rotation widget. The rotated widget doesn't change, and so this should be constructed beforehand and passed as a `child` parameter.

In Flutter, there are two main types of `Widget` which we usually extend: 

 - `StatelessWidget`: These widgets only depend on their current configurations (the final properties), and the _ambient state_ (these two combined will be referred to as _configuration_). _Ambient state_ is introduced by `InheritedWidget` into the widget tree,  which can be read by the descendants. For example, `InheritedTheme` extends this widget to provide a `ThemeData` instance to descendant widgets (obtained by calling the  `Theme.of()` function). We usually use the `provider` package instead. 
 - `StatefulWidget`: These widgets have a corresponding `State` object, which can contain variables. Calling the `setState()` function on the `State` object cause the widget to rebuild itself. 
 
> While a new `StatetfulWidget` instance may be created every frame, the corresponding `State` object will remain the same. 

With these in mind, let us take a look at the sample Counter application:

[DartPad](https://nullsafety.dartpad.dev/60e38246ce7b37e101bd03cd40786076)
```dart
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: MyHomePage(title: 'Flutter Demo Home Page'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  MyHomePage({Key? key, this.title = ""}) : super(key: key);

  final String title;

  @override
  _MyHomePageState createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  int _counter = 0;

  void _incrementCounter() {
    setState(() {
      _counter++;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            Text(
              'You have pushed the button this many times:',
            ),
            Text(
              '$_counter',
              style: Theme.of(context).textTheme.headline4,
            ),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _incrementCounter,
        tooltip: 'Increment',
        child: Icon(Icons.add),
      ),
    );
  }
}
```
As can be seen, in this application, we count the number of times the floating action button has been pressed. Since this is changes over time, it becomes a part of the application state, and so a `StatefulWidget` must be used. In this case, the widget will only contain the declaration of the configuration parameters, as well as a function to create a State object. Meanwhile, the layout will be created inside the corresponding `State` object instance. To understand this seemingly weird design choice, we have to understand how Flutter handles rendering under the hood.

## Flutter - Under the hood

While we have already seen the base class `Widget`, and the widget tree, there are two other important class: `Element` and `RenderObject` with their corresponding element and render tree.

On one side, we have the widget tree, corresponding to the actual layout we want to show to the user. Note that while the references form a tree, the same instance of a widget could be inside this tree multiple times. For example, adding the same `const Text("Hello World!")` text to the same layout a number of times will point to the same object (because of the `const` constructor). While this is generally disallowed in other frameworks, Flutter can handle this because of the way they defined widgets: "A widget is an immutable description of part of a user interface". Because it is only a description, it doesn't matter whether the same or different instances of a class is added.

On the other side, we have the render tree with `RenderObject` instances. This is the equivalent class to Android's `View` and iOS's `UIView` classes. They are large (both in code size and memory footprint), complex classes, handling the layout constraints and painting the given object with the provided options. They are usually optimized so that a new paint or new layout round only happens when a corresponding property has changed.

In the middle stands the element tree, connecting the objects found inside the widget tree to their render objects. Their use are multi fold. On one hand, they track the widget tree, making sure that after the widget tree is updated, the corresponding render objects draw the correct values on the screen. On the other hand, they provide extra functionality to the widget tree: we can store values inside the `Element` objects, which can be accessed by the children widgets. This is done through the `BuildContext` object, available at every `build()` call. A widget's corresponding `State` object is also stored here, making sure that the state object receives the new widget when it is updated.

When we start our application, the `runApp()` function will attach the root widget. The Flutter framework will create a corresponding `Element` instance, and add it to the root of the element tree. After the element is added, it will add the next child widget(s) to the widget tree (if there is any), and create the corresponding `RenderObject` instances adding them to the render tree if needed.

To showcase the connections between the trees, let us take a look at the following application:
import 'package:flutter/widgets.dart';

[DartPad](https://nullsafety.dartpad.dev/70c13d64b2991ff0735ea863a01f59be)
```dart
import 'package:flutter/material.dart';

void main() => runApp(
  Container(
    color: Color.fromRGBO(200, 200, 200, 1.0),
    child: Row(
      textDirection: TextDirection.ltr,
      mainAxisSize: MainAxisSize.min,
      children: [
        Image.network(
          "https://flutter.dev/assets/flutter-lockup-1caf6476beed76adec3c477586da54de6b552b2f42108ec5bc68dc63bae2df75.png",
          width: 90,
        ),
        Text(
          "Hello Flutter",
          style: const TextStyle(),
          textDirection: TextDirection.ltr,
        ),
      ],
    ),
  ),
);
```
and the corresponding trees:

**Kép a fákról**

As can be seen, a built-in widget will also typically contain a number of children widgets within it, which are hidden from us. For every widget in the fully expanded widget tree, there will be a corresponding `Element` object. An element may or may not create a `RenderObject`.

In conclusion, the `Element` is responsible for attaching further widgets into the widget tree, and attach new `RenderObject` instances into the render tree. However, to make the framework easier to use, the Flutter development team decided on transferring these responsibilities to more logical places.
 In the case of `StatelessWidget`, it was logical to put the `build()` function inside the widget: we regularly have to create new widgets, and this way we avoid declaring more classes, while also keeping the layout elements close to each other. 
 In contrast, with `StatefulWidgets`, the `build()` function can be found inside the `State` object. While this may seem counter-intuitive at first (why is the state responsible for other widgets?), the same could be said about `StatelessWidget` (why is the configuration of a layout responsible for other configurations?). 
 Indeed, the development team could have placed the `build()` function inside `StatefulWidget` as well, they have decided against it for practical reasons. When we build a layout with a state, we will more likely use the variables inside the state, and so it makes sense to build our widgets within the context of the state. 

## Flutter - Keys

Up until now we have learned how Flutter can recycle memory-intensive view-like objects with the help of the three trees. One major question remains: how does the element tree change when a new widget tree is provided? When is an element updated, when is it created, and when is it removed?

The general rule is that an `Element` object is constructed whenever a new widget appears somewhere in the widget tree. Changing the configuration of a widget (by creating a new instance with some properties changed) has no effect on the `Element`, since the type of the widget remains the same. It is only when a new type of widget is added in place of the old widget, or the widget is removed that the corresponding `Element` object will be removed.

An `Element` is only kept (with one exception) when the corresponding widget is found in the same place as in the old widget. 
