# Chapter 7: Persistent data storage

We've seen how we can handle data in apps involving user input and network communication in the previous chapters.

While many apps depend on network communication and memory caching, there are use-cases where local data storage - as in, storing data persistently on the device our app is running on - has to be implemented. Such use-cases could be as simple as storing the user's settings and as large and complex as supporting full-, or semi-offline features, including synchronizing local changes with a backend.

Let's take one step back to the basics. In this chapter, we'll look at persistent data storage options available in Flutter, including file handling, key-value stores, and relational databases.

## File operations

The project we'll be looking at here is the image_downloader sample app.

The app can save random images from Picsum as files into a specific directory on the filesystem and display the downloaded images in a grid. The app is designed to work on Android and iOS.

<p align="center"><img src="images/07_image_downloader.png" width=250/></p>

> We only have one GET network request for retrieving images in this simple app. We don't use the higher-level libraries discussed in chapter 6. This approach is, in fact, perfectly fine for prototyping and small projects.

### path and path_provider

While handling file and directory paths may seem like a basic task on modern frameworks, doing so in a cross-platform manner has many challenges. Just think about different path separator characters or dedicated folders on each platform. 

Fortunately, the Flutter platform team provides some packages to help us overcome this complexity with ease.

The [path](https://pub.dev/packages/path) package provides top-level functions for manipulating file system paths, like `join()` and `split()`.  After adding *path* to the project's *pubspec.yaml* file as a dependency, we can import it with a prefix in any *.dart* file to start using the provided functions.

```dart
import 'package:path/path.dart' as path;
```

With that import in place, we can use *path* like this (example taken from *image_downloader*'s main.dart):

```dart
path.join(directory.path, IMAGES_DIR))
```

The [path_provider](https://pub.dev/packages/path_provider) package, on the other hand, gives us functions that can return paths to specific, dedicated folders on the supported platforms. We can add *path_provider* to a project the same way as we added *path*. 

We can find an example for using one of path_provider's methods - `getApplicationDocumentsDirectory()` - in the `_getImageDirectory()` function of `_ImageDownloaderPageState`.

```dart
Future<Directory> _getImagesDirectory() async {
  final directory = await getApplicationDocumentsDirectory(); // <- Here
  return Directory(path.join(directory.path, IMAGES_DIR)).create();
}
```

`getApplicationDocumentsDirectory()`  returns platform-specific directory paths:

- On iOS, it uses the `NSDocumentDirectory` API to get the folder where the current app may place user-generated data.
- On Android, it uses `Context.getDataDirectory()` to get the app's own private data storage folder.
- On other platforms, this method throws a `MissingPlatformDirectoryException`.

Some other path_provider functions to check out:

- `getApplicationSupportDirectory()`
- `getDownloadsDirectory()` 

> For demonstration purposes, we use a simple import for path_provider and we call `getApplicationDocumentsDirectory()` without a prefix. However, we could import path_provider.dart with an alias and use its functions with a prefix as we did with path.

There's one more thing to discuss that makes image_downloader tick, and that's classes from the `dart:io` package. Like in most programming languages, `File` in Dart is a reference to a file on a file system with the ability to manipulate the referenced file. The same applies to the `Directory` class and directories.

With this knowledge in our pockets, let's take a look at `_ImageDownloaderPageState`'s three functions that drive the *image_loader* app.

First of all, `_getImageDirectory()` is responsible for creating a `Directory` object that references the directory we'll be storing the downloaded images in and also from where we'll be loading them to be shown on the UI. 

```dart
Future<Directory> _getImagesDirectory() async {
  final directory = await getApplicationDocumentsDirectory();
  return Directory(path.join(directory.path, IMAGES_DIR)).create();
}
```

The `_downloadNewImage()` function downloads a new random image from Picsum, stores it under a random name (a generated UUID + ".jpg"), and refreshes the UI state afterward.

```dart
Future<void> _downloadNewImage() async {
  final response = await http.get(Uri.parse("https://picsum.photos/400")); // Query the image
  final imagesDir = await _getImagesDirectory(); // Get the target directory
  final filePath = path.join(  // Create the absolute path the file will be saved to
    imagesDir.path,
    "${uuidGenerator.v4().toString()}.jpg",
  );
  final file = File(filePath); // Create a File object for file handling
  await file.writeAsBytes(response.bodyBytes); // Write the bytes of the image to the file
  print("Image downloaded to: $filePath");
  setState(() {
    _imageFiles = _loadImages(); // Refresh the state
  });
}
```

> Note that we've changed the file naming scheme compared to what was seen in the lecture, as that implementation didn't guarantee to generate unique file names on each call. Now we use the [uuid](https://pub.dev/packages/uuid) package to generate random UUIDs for file names.

Last but not least, there's the `_loadImages()` function that returns a `Future<List<File>>` object containing a list of references to the downloaded image files.

```dart
Future<List<File>> _loadImages() async {
  final imagesDir = await _getImagesDirectory();
  return imagesDir
      .list() // Lists immediate subdirectories and files
      .where((element) => element.path.endsWith(".jpg")) // Filter for JPG files
      .map((e) => File(e.path)) // Map FileSystemEntity objects to File objects
      .toList(); // Convert resulting Iterable<File> to List<File>
}
```

> Note that we use the same asynchronous data loading logic with `FutureBuilder` as we did in chapter 6. Namely, storing a `Future` reference in a `StatefulWidget`'s state and passing that reference to a `FutureBuilder` in the `build()` method.

## A Todo app without persistent storage

In this section, we'll be looking at variations of a Todo list application. The [todo_starter](../projects/chapters/chapter_07/todo_starter) project contains the base framework that we can extend with persistent storage solutions. While we can delete existing todos and create new ones, the same three todos will show up again after restarting the app.

<p align="center">
  <img src="images/07_todo_starter.png" width=250/>
  <img src="images/07_todo_starter_details.png" width=250/>
  <img src="images/07_todo_starter_new" width=250/>
</p>

##  The Todo app with persistent key-value storage

Before diving into how we can persist our todos, we'll take a look at an implementation of hiding already done todos with a "switch" (which will be a `Checkbox`). The project for this section is [todo_shared_prefs](../projects/chapters/chapter_07/todo_shared_prefs)

<p align="center">
  <img src="images/07_todo_prefs.png" width=250/>
  <img src="images/07_todo_prefs_hidden.png" width=250/>
</p>

This setting is persisted between app restarts. We'll use the first-party [shared_preferences](https://pub.dev/packages/shared_preferences) package to store a `Boolean` value referenced with a `String` key.

The shared_preferences package wraps platform-specific persistent key-value storage solutions that can store simple data, like `bool`s, `int`s, `String`s, etc.

> To be more specific, shared_preferences wraps the following solutions on the supported platforms:
> - **Android:** SharedPreferences
> - **iOS/macOS:** NSUserDefaults
> - **Web:** window.localStorage
> - **Linux/Windows:** a *shared_preferences.json* file in `PathProvider.getApplicationSupportPath()`

After adding the package to our *pubspec.yaml* file and updating the dependencies, we can get a reference to the singleton `SharedPreferences` instance by calling the static `SharedPreferences.getInstance()` function. This function loads the wrapped platform implementation asynchronously, so we have to handle it like any other `Future` that provides us data for building the UI. An example for this can be found in `todo_list.dart / _TodoListPageState`.

```dart
class _TodoListPageState extends State<TodoListPage> {
  DataSource _todosDataSource;
  late Future<List<Todo>> _todosFuture;
  Future<SharedPreferences> _prefs = SharedPreferences.getInstance(); // Get SP instance
  
  static const HIDE_DONE_TODOS_KEY = "HIDE_DONE_TODOS"; // Define a key
  late Future<bool> _hideDoneTodos; // Declare a Future for retrieveing a value from SP
  
  _TodoListPageState(this._todosDataSource);
  
  @override
  void initState() {
    _todosFuture = _todosDataSource.getAllTodos();
    _hideDoneTodos = _prefs.then((prefs) {
      return prefs.getBool(HIDE_DONE_TODOS_KEY) ?? false; // Retrieve value for the defined key
    });
    super.initState();
  }
  // ...
}
```

In the code snippet above, we use one of the getter functions available for retrieving typed values from `SharedPreferences`, namely `getBool(key)`. If `SharedPreferences` doesn't have a value stored for a key, the getter functions will return `null` for that key.

Let's take a detour and see how we can implement the menu item with a checkbox that will both display and set the state of our `bool` setting in `SharedPreferences`.

```dart
@override
Widget build(BuildContext context) {
  return Scaffold(
    appBar: AppBar(
      title: Text("Todo List"),
      actions: [
        PopupMenuButton(
          onSelected: onPopupMenuItemClicked,
          itemBuilder: (context) {
            return [
              PopupMenuItem(
                value: HIDE_DONE_TODOS_KEY,
                child: Row(
                  children: [
                    Text("Hide done todos"),
                    FutureBuilder<bool>(
                      future: _hideDoneTodos,
                      builder: (context, snapshot) {
                        if (snapshot.hasError ||
                            snapshot.connectionState ==
                                ConnectionState.waiting) {
                          return Checkbox(
                            tristate: true,
                            value: null,
                            onChanged: null,
                          );
                        } else {
                          return Checkbox(
                            value: snapshot.data,
                            onChanged: null,
                          );
                        }
                      },
                    ),
                  ],
                ),
              )
            ];
          },
        ),
      ],
    ),
    // ...
  );
}
```

We can build AppBar menu actions with any widget - we're probably quite used to this by now. However, some widgets play nicely together in this context and make it easy to implement `AppBar` popup menus defined by Material Design. The ones we're using here are `PopupMenuButton` and `PopupMenuItem`. The single item we're building uses a `FutureBuilder` to await the value requested from `SharedPreferences` and build the included `Checkbox` accordingly. The popup menu selection callback has to be passed to the `PopupMenuButton`, and it will be called with the object we pass to `PopupMenuItem.value` - which is a String in our case.

```dart
void onPopupMenuItemClicked(String selectedItemValue) async {
  if (selectedItemValue == HIDE_DONE_TODOS_KEY) {
    final prefs = await _prefs;
    final hideDoneTodos = !(prefs.getBool(selectedItemValue) ?? false);
    refreshTodos(() {
      _hideDoneTodos = prefs.setBool(selectedItemValue, hideDoneTodos).then(
        (bool success) {
          return hideDoneTodos;
        },
      );
    });
  } else {
    // Do nothing
  }
}
```

> We pass the `SharedPreferences` updating logic as a lambda expression to `refreshTodos` to ensure that persisting the new value happens before rebuilding the UI.

Let's jump to the code where we build the Todo list UI and look at how we can handle multiple `Future`s at once.

```dart
@override
Widget build(BuildContext context) {
  return Scaffold(
    appBar: AppBar(/*...*/),
    body: FutureBuilder<dynamic>(
        future: Future.wait<dynamic>([_todosFuture, _hideDoneTodos]), // <- Await multiple Futures
        builder: (context, asyncSnapshot) {
          if (asyncSnapshot.hasError) {
            return Center(/*...*/);
          }
          if (asyncSnapshot.hasData) {
            List<Todo> items = (asyncSnapshot.data[0] as List<Todo>).toList(); // <- Use first Future's value
            int itemCount = items.length;
            bool hideDoneTodos = asyncSnapshot.data[1] as bool; // <- Use second Future's value
            if (hideDoneTodos) { // <- Apply filtering if needed
              items.removeWhere((element) => element.isDone);
              itemCount = items.length;
            }
            return ListView.builder(/*...*/);
          }
          return Center(
            child: CircularProgressIndicator(),
          );
        }),
    floatingActionButton: FloatingActionButton(/*...*/)
  );
```

To build the correct state of the todo list UI, we have one more factor to consider now: do we need to display the filtered or unfiltered todo list? Retrieving the list and getting the filtering switch's value from `SharedPreferences` are asynchronous operations. We need to have both values ready to do the filtering if required before building the `ListView`.

This is where a neat feature regarding `Future`s come to the rescue. We can use `Future.wait<T>([Future<T>, Future<T>, ...])` to wrap multiple `Future`s with one that only completes when all the wrapped ones are completed. If the wrapped `Future`s return with the same type T, the wrapping `Future` returns with  `List<T>`, and the contents will be the results of the wrapped `Future`s in the same order that we passed them to  `Future.wait`.

However, we have a special case on our hands, as `_todosFuture` returns a `List<Todo>` and `_hideDoneTodos` returns a `bool`. To handle this case, we have to step out of the safety of strong typing and use the `dynamic` type until we can get back on solid ground. We're safe again after we cast each item in `asyncSnapshot.data` - which is the result we get from awaiting the two mentioned futures - back to `List<Todo>` and `bool` respectively.

> The dangerous part of this approach is that we - or any other developer touching this kind of code - can forget to cast the items, or we can cast them to the wrong type by accident. In both cases, the result will most likely be a runtime error, as compile-time type checking is disabled for everything of the `dynamic` type.

## Relational databases

## NoSQL databases