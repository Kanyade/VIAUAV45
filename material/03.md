# Essential Flutter Widgets

In the previous chapters we've gotten familiar with Dart and the basic structure of a starter Flutter project.

Now we'll take a look at some fundamental widgets that you'll encounter in most Flutter projects along with basic layouts and UI elements.

> To start each example from the [chapter's demo project](/projects/chapters/chapter_03), use the `flutter run -t lib/main.dart` command, changing `main.dart` to the file you want to be the entry point of the app.
> In Android Studio, you can create launch configs for each entry point file.
> // TODO You can also select a file to run on the toolbar of AS

## The App Widgets

While we definitely *could* build every aspect of a Flutter app ourselves from the ground up, it doesn't mean we really *should* go down on that path.

The [`WidgetsApp`](https://api.flutter.dev/flutter/widgets/WidgetsApp-class.html) widget is there to provide basic functionality for apps.

By making a `WidgetsApp` the top level widget in our app's widget tree, it makes implementing the following functionalities really straight-forward:

- Defining the default text style for every widget in the app
- Handling localization
- Navigation between pages (screens)
- Handling overlays, like dialogs that can be displayed over other content

`WidgetsApp` seems to be a class with a lot of responsibilities, but under the hood it delegates these responsibilities to other widgets, like [`DefaultTextStyle`](https://api.flutter.dev/flutter/widgets/DefaultTextStyle-class.html), or [`Navigator`](https://api.flutter.dev/flutter/widgets/Navigator-class.html).  

If our goal was to build a game with widgets only, or to build a regular app with our own design language, `WidgetsApp` pretty much has us covered.

A really simple app with a single page looks something like this:

// TODO Code of a simple app using WidgetsApp, maybe a game's menu's UX wireframe-style UI

However, Flutter has built-in support for [Material Design](https://material.io/), Google's all-around design language, and even for Apple's [Human Interface Guidelines on iOS](https://developer.apple.com/design/human-interface-guidelines/ios/). Flutter's implementation of the latter is called Cupertino.

> As we already know from the previous chapters, Flutter is using the supported platforms' native canvases to render UI widgets. 
> This means that _technically_ we can build an app using Cupertino UI widgets only, and the app will run on all supported platforms, though due to licensing issues, Cupertino won't have the correct fonts on any other platform than iOS or macOS. 
> // TODO Screenshot of a Cupertino app (like Hello world) on an Android emulator and iOS simulator

Let's take a closer look at some app building blocks from the aforementioned implementations.

## Material Design app basics

### MaterialApp

`MaterialApp` is a `StatefulWidget` wrapping many other widgets that are required for material design applications. It builds upon and extends the functionality of a `WidgetsApp`.

One of the functionalities that `MaterialApp` offers is Material-specific navigation handling (navigation meaning navigating between pages). We'll get back to discussing navigation in Chapter 5 of this material.

`MaterialApp` is also responsible for providing default theme and style values for Material widgets.

#### ThemeData

We can use `ThemeData` objects to configure themes for Material apps.

Material theme colors (like `primaryColor` or `accentColor`) can be defined individually in a `ThemeData`, but *swatches* can also be used. A *swatch* is basically a collection of color shades generated (and for built in swatches, hardcoded) from a base color. A *swatch* is a *color palette*.

The [official documentation of the Material color system](https://material.io/design/color/the-color-system.html) goes into further details about color palettes. Also, if we wanted to create our own Material color palette, we could use the [color tool](https://material.io/resources/color/).

Apart from the main theme colors, we can even customize most of the Material widgets' colors individually with a `ThemeData`, as well as global text and icon themes.

### Scaffold

`Scaffold` implements the basic layout structure of a Material Design page. Although it has many "slots" that accept `Widget`s, there are some widgets that are designed to be used together with `Scaffold` to easily create standard Material pages.

A `Scaffold` can manage the following Material components (the list is not exhaustive):

 - [App bar](https://material.io/components/app-bars-top)
 - [Floating action button](https://material.io/components/buttons-floating-action-button)
 - [Navigation drawer](https://material.io/components/navigation-drawer)
 - [Bottom navigation](https://material.io/components/bottom-navigation)

The middle area of a `Scaffold` is called the `body`. We can use the `body` of a `Scaffold` to display the contents of a page and - not very surprisingly - we can use any `Widget` to do it. 

### AppBar

The `AppBar` widget implements a standard Material [app bar](https://material.io/components/app-bars-top) (also known as a Toolbar, previously known as an ActionBar).

We have full control over the content of an `AppBar`. Instead of a back navigation arrow or a hamburger menu icon, we can use any `Widget` to define the leading content, and the title can also be any `Widget`, not just `Text`.

While we're free to build any widget hierarchy for `AppBar`s slots, there are some widgets that play nicely with `AppBar` by design:

 - `Icon` 
 - `IconButton`
 - `PopupMenuButton`

> We'll discuss widgets implementing more Material Design UI elements in Chapter 5.

## Cupertino app basics

Now, let's get familiar with the Cupertino "equivalents" of the previously mentioned Material widgets. 

### CupertinoApp

The `CupertinoApp` widget has the same responsibilities as its [Material counterpart](#materialapp). One significant difference between the behaviors of `CupertinoApp` and `MaterialApp` surfaces when we don't define the top level themes explicitly. `MaterialApp`'s theme defaults to the value of `ThemeData.light()`, while `CupertinoApp` will use colors provided by iOS. 

#### CupertinoThemeData

As the [Human Interface Guidelines' Color](https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/color/) section suggests, `CupertinoThemeData` has much lex flexibility compared to Material's `ThemeData`. There are only for colors, and the text theme to define.

### CupertinoPageScaffold

### CupertinoTabScaffold

### CupertinoNavigationBar

## Common UI Widgets

### Text

Text rendering, text styling, custom style/theme

### Icon

Material, Cupertino icon pack, icon tinting, custom icons?

Only squared icons! Non-squared icons may render incorrectly.

### Image

Image.asset, how to declare assets, pubspec.yml, assets folder

Image.network, load images from URLs, headers, cache

loadingBuilder, errorBuilder, color

### SizedBox

## Layout Widgets

### Container

Margin, Border, Padding

Decorations

### Stack

### Center

### Column

Vertical alignment of children

Main Axis, Cross Axis

### Row

Horizontal alignment of children

Main Axis, Cross Axis

mainAxisSize: MainAxisSize.min

### Expanded

Fit into a Column/Row, layout weight (flex factor)

## Further reading, materials

- [Layouts in Flutter](https://flutter.dev/docs/development/ui/layout)
- [Understanding constraints](https://flutter.dev/docs/development/ui/layout/constraints)
- [Building a Cupertino app with Flutter (Codelab)](https://codelabs.developers.google.com/codelabs/flutter-cupertino)

