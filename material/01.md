

# Chapter 1: Introduction

In the last few decades, several different electronic platforms have emerged to aid our everyday life. Today, there are two main categories for typical usage: desktop and mobile platforms, with many different operating systems to run applications on.

Due to their history, desktop operating systems have mostly stabilized: Windows, macOS, and Linux. Meanwhile, the mobile platform is more dynamic: while Android and iOS are currently the two main operating systems, others have come and go (Symbian, Windows Phone), while others are still in development (Google's Fuchsia, Huawei's Harmony).

***Kép platformokról***

On another side, web platform technologies have grown to the point where standalone applications can be developed. Starting as a way to share information with other users through images, texts, and hyperlinks, the capabilities of websites gradually grew, thanks to the use of browser-side code execution with Javascript and the browsers providing a way to reach different native interfaces.

Having so many different environments, one key factor to determine before developing an application is the target platform. This is further complicated by the fact that in today's society, one user typically owns multiple devices running different platforms, where a seamless cross-platform experience is a requirement. Due to these reasons, cross-platform development is usually chosen for a given application.
## Cross-platform development
Developing an application for multiple different platforms can be achieved in several ways:
- Native: Develop an application for every supported operating system with its native development framework. While performant and every platform-specific resource is available, it also incurs high development costs due to little to no code sharing. In-depth testing must also be done for every platform.
- Responsive website: Since a web browser is available for every consumer focused device, creating a website can be a reasonable alternative. A responsive website can accomodate different screen sizes, making it accessible for both desktop and mobile users. Depending on what features a browser supports, web applications can query the device's geographical location, provide offline support and push notifications, record audio and video, or even manage Bluetooth connections (for a detailed list, see [here](https://whatwebcando.today/)). If the web applications conforms to the requirements set by the browser, it is considered to be a Progressive Web Application (PWA), providing the option to install it as a standalone application for the user.
- Hybrid: While browsers expose many useful interfaces for web sites, a numer of features are still not available (or are in experimental stages), such as NFC access or shape detection. In these cases, a platform-specific application is neccessary. To circumvent the need for a native application, an option is to package our web application with a custom browser exposing these native interfaces into a standalone application (similar to how a Java application can be packaged with the JVM into a single executable application). Electron is such a framework, used in many applications such as Facebook Messenger for desktop platforms, Twitch or Discord.
-  Native cross-platform: Frameworks such as React Native, NativeScript and Xamarin Native provide tools to write applications in a common programming language, while also allowing the use of platform specific native UI components. The application may be executed with the help of some kind of virtual machine, or may be compiled to native machine instructions.

Every approach comes with its advantages and disadvantages, which must be weighted at the start of development.

## Flutter
Flutter is an open-source cross-platform development framework maintained and owned by Google. Being relatively new, the first preview version was released in 2015, while the first production-ready stable version became available in 2018. The main goals of Flutter consist of the following:
- Compile native applications for mobile, web and desktop from a single codebase.
- Provide fast development cycle with the help of Stateful hot reload.
- Support native UI components with extensive customizability.
- Native-like performance in applications.

Currently, the following platforms are supported:
- Android: Stable, initial
- iOS: Stable, initial
- Web: Beta, 2019
- Windows, macOS, Linux: Alpha, 2019

For the programming language, the development team chose Dart to develop the framework as well as to write applications with it. Dart is programming language owned by Google. Starting out as a compiled language running on the Dart VM with the intent to replace JavaScript in web browsers, they failed to convince Chrome's development team (a browser also owned by Google) to include a Dart VM in their application, and so refocused their efforts into providing a JavaScript transpiling tool. While Google uses it for their own projects, it failed to gain wide-spread propularity, staying mainly as a niche language until Flutter was released.

Flutter can be considered to be a hybrid cross-platform framework, where instead of a web site, we create our application with Dart. Native cross-platform frameworks usually run into the 'lowest common denominator' problem, wherein the same UI component of different platforms might have different properties, such as different animation style, different shapes and different functionalities, and so the cross-platform library can only expose the common properties with ease. Also, subtle differences between native components and behaviours can easily break an app in obscure ways, and debugging them also becomes harder due to the added communication layer.

To combat these, the Flutter team decided to stay away from native components. Instead, they have re-created every UI component in Flutter which gets drawn by the engine running our application. This way, Flutter can support many platforms with less effort: the only requirements are a way to draw pixels on the screen (which is usually available through some kind of Canvas component), a way to handle raw user inputs (such as a touch screen or mouse inputs), and a way to run machine code compiled from C++ (available on most platforms). This way, an application will generally run the same independent of platform, and the styling is up to the developer: for example, an application created with Material Design in mind will run the same on iOS.

To achive this, Flutter consist of 3 main parts: the framework, where the UI components and other application funcionalities are implemented, the engine running our application, and the platform-specific embedder. The following figure gives an overview of the architecture behind Flutter:
 
 ***Kép Flutter felépítésről***

In most frameworks, there is a tradeoff between fast compilation and performance of an application. To achive hot-reload (where changes in the source can be instantly seen in the application), frameworks only analyze the source code for correctness and small processing, which will be then run directly on the device. In turn, to be performant, the source code is compiled with optimizations enabled, which increases compilation time.

With this in mind, Flutter provides two separate build process:
- In *debug* mode, an analyzer is run to make sure that the source code is syntactically correct. The source files are packaged with the Dart VM. Starting the application will load the source from this package into the memory. While running, triggering a hot reload (usually by saving) will replace these source files in the memory, changing the behaviour of the program. Restarting the application will load the original source files again. This allows fast development cycles at the cost of low performance.
- In *release* mode, Dart code is compiled into native machine instruction while also linking some runtime libraries (such as garbage collection). While the compilation time is longer, the resulting application will be smaller and faster. Running them on emulators is not officially supported (however, Android x86_64 seems to be working).
- There is also *profile* mode, which is similar to *release*, with the exception that a few debugging utilites are enabled to benchmark the performance of the application.

## Dart programming language

Dart is a modern object-oriented, class based, garbage collected language with a syntax somewhat similar to Java. Let's look at some examples to understand how Dart code works. For every example, a DartPad link is provided, which opens the code in the browser in a Dart environment.
### Hello World
[DartPad](https://nullsafety.dartpad.dev/ff11838f11913e246e720a888acce2f3)
```dart
void main() {
  print("Hello World!");
}
```
Like with many other languages, every Dart application starts in a globally defined *main* function. From this, we can already see a few properties: void shows that the function does not return a value, while the parenthesis after the function name indicate that the *main* function does not take parameters. Optionally, we could declare a parameter with the type of a list of strings to accept command line parameters.
The first thing we as developers will probably do is declare variables. Since 2.0, the Dart language is type-safe: static type checking and runtime checks are used to ensure that a variable's runtime type matches the static type, also referred to as sound typing. While types are mandatory for variables, type annotations are usually optional due to the included type interference.
Since Dart 2.10, Dart also contains nullability as a type parameter to achive sound null safety. While still in beta with Flutter, we decided on using it to include nullability since this will be an important part of future Flutter applications. Like with Kotlin, variables must be annotated showing whether they can contain a *null* value or not.
With these in mind, let's take a look at different variable declarations.
### Variable declaration
[DartPad](https://nullsafety.dartpad.dev/c09129d1a0fed7990d7d9b44d6b32728)
```dart
//Global variable
bool globalFlag = false;

void main(List<String> args) {
  //Declaration with initialization
  String myString = "My string";
  print("String interpolation: $myString");
 
  //Declaration without initialization
  String tempString;
  //print(tempString.length); //!ERROR! Non-null value not initialized
  if (globalFlag){
    tempString = "True";
  } else {
    tempString = "False";
  }
  print("String after initialization: $tempString");
  
  //Object initialization
  Duration myDuration = Duration();
  print(myDuration);
  
  String? myNullString;
  print("Null coalescing: ${myNullString ?? "Null variable!"}");
  //print(myNullString.length); !ERROR! Function call on nullable variable
  print("Null aware property access: ${myNullString?.length}");
 
  var myAutoVar = "Automatic type";
  
  final myFinalVariable = "Hello";
  final myOtherFinalVariable = myAutoVar;
  const myConstVariable = "World!";
  //const myOtherConstVariable = myAutoVar; //!ERROR! Const value must be initialized with a constant value
}
```
A variable can be declared globally, locally in a function, or as a property of classes, while the initialization can happen at declaration, or at a later point in the case of local variables. If the variable is initialized as it is declared, the type can be inferred from the value, in which case the *var* keyword can be used instead of the type annotation.
Dart provides a number of in-built classes, some of the most important being:
- *int*
- *double*
- *num*: a supertype of *int* and *double*
- *bool*
- *String*
- Collections, such as *List*, *Set*, *Map* 

A *final* variable can only be set once at initialization. A *const* variable is a constant-time expression which will be evaluated at compilation. If a constant object is created the parameters in the constructor must also be constants. In this case, two calls to the constructor with the same parameters will 'return' the same object.


If a variable is not explicitly initialized before use, it will contain the *null* value. In this case, the variable must be declared as a nullable type, while non-nullable variables must be initialized before use.
In the case when we know a variable will be initialized before use, we can create a non-nullable type variable with the keyword *late*, as shown in the following example:

[DartPad](https://nullsafety.dartpad.dev/c09129d1a0fed7990d7d9b44d6b32728)
```dart
bool test1(){
  print("Test1 function");
  return true;
}

bool test2(){
  print("Test2 function");
  return true;
}

late int testVariable;

void main(List<String> args) {
  //print("Late variable without initilaization: $testVariable"); //!RUNTIME ERROR! LateInitializationError
  testVariable = 5;
  print("Late variable after initialization: $testVariable");
  
  bool flag1 = test1();
  late bool flag2 = test2();
  print("Flag1 value: $flag1");
  print("Flag2 value: $flag2");
}
```
Using a *late* variable before initialization will result in a *LateInitializationError* being thrown. Annotating a local variable with the *late* keyword will make it to be lazily initialized (meaning that the initialization will only happen the first time the value is read). Note that globally declared variables are inherently lazy initialized unrelated to it being *late* or not.

Two special types are *Null* and *dynamic*:
[DartPad](https://nullsafety.dartpad.dev/b71678b6d1b7d992b7ce7e77cf39c43e)
```dart
void main(){  
  //Null value
  int? nullInt;
  print("Null values");
  print(nullInt.runtimeType);
  print(nullInt.hashCode);
  print(nullInt.toString());
    
  //Dynamic type
  dynamic testDynamic;
  testDynamic = 5;
  print(testDynamic.runtimeType);
  testDynamic = "Hello Dynamic!";
  print(testDynamic.runtimeType);
  //testDynamic.gcd(3); //!ERROR!
}
```

*Null* a special type, with the only instance being *null*. Because *null* is an object, it contains the *runtimeType* and *hashCode* properties and the *toString* function, which can be freely used.
The *dynamic* declaration tells the compiler to skip type checks for the given variable. Because of this, a *dynamic* variable can contain any value, and any function can be called on it. Runtime type checks are still used: assigning a dynamic variable to a statically typed variable will result in an exception if the assignment is not possible.
### Functions
Beside variables, function declaration and usage are also an important part of programming languages. The following code sample contains every important aspects of functions in Dart:

[DartPad](https://nullsafety.dartpad.dev/d9062516ed12df8e715a0910dd464b76)
```dart
void mySimpleFunction(){
  print("Inside function.");
  return;
}

int calculateSomeValue(int a, int b) => a + b;

void namedParametersFunction({String? name, String? description}){
  print("$name: $description");
}

positinalParametersFunction(int a, [int? b]) => a + (b ?? 0);

lambdaParameterFunction (void Function (int a) lambda){
  lambda(10);
}

void main() {
  mySimpleFunction();
  print(calculateSomeValue(3,5));
  
  namedParametersFunction(name: "Dani");
  namedParametersFunction(description: "Hello", name: "Dani");
  
  print(positinalParametersFunction(3));
  print(positinalParametersFunction(3,4));
  
  void myLocalFunction(){
    print("Function inside function!");
    return;
  }
  myLocalFunction();
  
  var myLambdaExpression = (int a, int b) => print(a+b);
  myLambdaExpression(1,1);
  var myLambdaDetailedExpression = (){
    print("Inside lambda expression");
    return 1;
  };
  print(myLambdaDetailedExpression());
  print(myLambdaDetailedExpression.runtimeType);
  
  lambdaParameterFunction((int a){
    print(a);
  });
}
```
A function declaration usually starts with the definition of the type of the returned value. If the function doesn't return any value, *void* can be used, or the type declaration can be skipped. Additionally, if the function never returns normally (always throws an exception or runs in an infinite loop), the *Never* type can be used to symbolize this.
If the return type is non-nullable, a value must be returned from the function. If the return type is nullable, the *return* can be skipped, in which case the *null* value will be returned implicitly.

The type declaration is followed by the name and the input parameters of the function. Dart supports higher-order functions, meaning that the functions themselfs can be used as variable, and they can be passed to other functions as parameters. The type declaration of such a variable follows the following format: 

    <return type> Function(<parameters>) <variableName>

Dart has three different types of parameters:

 - *Required positional parameter*: These parameters must be passed to the function. The parameters are identified by the position in which they are passed.
 - *Optional positional parameter*: These parameters are optional. They follow the required positional parameter(s). If a value is not given, an optional compile-time constant can be used as a default value, otherwise null will be passed. They can be found inside the squared brackets *[]*.
 - *Optional named parameter*: These parameters are also optinal. They are passed to the function with the name of the parameter, followed by the value. Because of this, the order of them is irrelevant. If a value is not given, an optional compile-time constant can be used as a default value, otherwise null will be passed. They can be found inside the curly brackets *{}*.

The statements of the functions can be found inside the curly brackets (*{}*). If the function only consists of one statement, it can be shortened with the *=>* syntax, in which case the *return* keyword is also skipped.

## Installing Flutter SDK
## Installing Flutter in Android Studio
## Installing Flutter in Visual Studio Code




### Vezérlési struktúrák
[DartPad](https://dartpad.dev/02741c2e7f2f8592022a4fa27d609b05)
```dart
void main() {
  bool myFlag = true;
  if (myFlag){
    print("True");
  } else if (!myFlag) {
    print("False");
  } else {
    print("Null");
  }
  
  for (int i = 0; i < 4; i++){
    print(i);
  }
  
  for (var j = ""; j.length < 4; j += "a"){
    print(j);
  }
  
  var j = 0;
  while(j < 6){
    j++;
    if (j == 3)
      continue;
    print(j);
  }
  do{
    print("Do-while");
    break;
  } while(true);
  
  var myList = [3, 4, 7];
  for (var value in myList){
    print(value);
  }
  
  var mySwitchVariable = 'Hello';
  switch (mySwitchVariable) {
    case 'Hello':
      print("Első");
      break;
    case 'World':
      print("Második");
      break;
    case 'TEST':
      print("Minden más");
      break;
    default:
      print("Ismeretlen");
  }
  
  assert(mySwitchVariable != "Hello");
  
  String nullVariable;
  try{
    nullVariable.substring(0);
  } on NoSuchMethodError catch(e){
    print("Error caught!");
  } finally {
    print("Finally called!");
  }
}
```

### List, Map, Set

[DartPad](https://dartpad.dev/42ee8b89b2805ff1b8edac5991c87eeb)
```dart
void main() {
  var myList = List();
  myList.add(5);
  myList.add("Hello");
  myList.add(Duration());
  print(myList);
  print(myList[1]);
  
  var myTypedList = List<String>();
  myTypedList.add("Hello");
  myTypedList.add("World!");
  //myTypedList.add(3); !ERROR!
  
  var myAutomaticList = [
    "World!",
    5,
    null
  ];
  print(myAutomaticList.runtimeType);
  
  var myIntList = [3, 5, 6, 18, 2];
  print(myIntList.length);
  print(myIntList.firstWhere((it) => it.isEven));
  print(myIntList.where((it) => it.isEven));
  //myIntList = myIntList.where((it) => true); !ERROR!
  myIntList.where((it){
    print("Inside where with: $it");
    return it.isEven;
  }).map((it){
    print("Inside map with: $it");
    return it.toString();
  }).firstWhere((it){
    print("Inside firstWhere with: $it");
    return it.length > 1;
  });
  print(myIntList.indexOf(8));
  //FONTOS! A dupla pont jelentése
  print(myIntList..retainWhere((it) => it.isEven));
  print(myIntList..sort((e1, e2) => e1.compareTo(e2)));
  //print(myIntList[5]); !ERROR!
  
  var myMap = {
    "test1" : 2,
    "test2" : 3,
    null : 2
  };
  print(myMap.runtimeType);
  print(myMap.keys);
  print(myMap.values);
  print(myMap.entries);
  
  var mySet = {1, 4, 6, 5, 4, 2, 1, 3};
  print(mySet);
  mySet.add(6);
  print(mySet);
  print(mySet.difference({4, 6, 9}));
  print(mySet.union({4, 6, 9}));
  print(mySet.intersection({4, 6, 9}));
  
  var whatIsThis = {};
  print(whatIsThis.runtimeType);
}
```

### Listák létrehozása feltételes kifejezésekkel

[DartPad](https://dartpad.dev/d87cea912ab2be236a30702713ba26b4)

```dart
import 'dart:math';

int testFunction(){
  return 4;
}

void main() {
  var myFirstList = [3, 5, 9];
  var mySecondList = [1, 2, 4, 5];
  print(myFirstList + mySecondList);
  myFirstList.addAll(mySecondList);
  print(myFirstList);
  
  var itemFlag = true;
  var myDetailedList = [
    1,
    itemFlag ? 2 : 9,
    if (itemFlag)
      3,
    testFunction(),
    for(int j = 5; j < 6; j++)
      j,
    ...myFirstList,
    ...mySecondList.map((it) => it + 1),
    for (int j = 11; j < 13; j++)
      ...[
        j,
        j * 2,
      ],
    for (var item in mySecondList)
      (){
        for (int i = 0; i < 10; i++){
          if (item == pow(2, i))
            return 0;
        }
        return item;
      }(),
  ];
  print(myDetailedList);
  
  //var myGenerator = ...[3, 2, 1]; !ERROR!
}
```
### Osztályok
[DartPad](https://dartpad.dev/51a9b8cc3b6cd4b9e673490d894ee468)
```dart
class PointClass{
  double x;
  double y;
  
  PointClass(double x, double y){
    this.x = x;
    this.y = y;
  }
  
  @override
  String toString(){
    return "PointClass(x: $x, y: $y)";
  }
}

class ConstPointClass{
  final double x;
  final double y;
  
  const ConstPointClass(double x, double y) : this.x = x, this.y = y;
  
  @override
  String toString(){
    return "ConstPointClass(x: $x, y: $y)";
  }
}

class VectorClass{
  double x;
  double y;
  
  VectorClass(this.x, this.y);
  VectorClass.zero() : this(0, 0);
  
  static final List<VectorClass> _poolList = [];
  factory VectorClass.pooled(){
    if (_poolList.isNotEmpty){
      return _poolList.removeLast()
        ..x = 0
        ..y = 0;
    } else {
      return VectorClass.zero();
    }
  }
  void recycle(){
    _poolList.add(this);
  }
  
  
  @override
  String toString(){
    return "VectorClass(x: $x, y: $y)";
  }
  
  @override
  int get hashCode => x.hashCode ^ y.hashCode;
  
  @override
  operator ==(dynamic other) => other is VectorClass && other.x == x && other.y == y;
  
  operator +(VectorClass other) => VectorClass(x + other.x, y + other.y);
}

enum Colors{
  RED, BLUE, GREEN
}

abstract class Listenable{
  void addListener(void Function(dynamic));
  void notifyListeners();
}
class ListenableInt extends Listenable{
  int value;
  @override
  void addListener(void Function(dynamic) Function) {
    // TODO: implement addListener
  }

  @override
  void notifyListeners() {
    // TODO: implement notifyListeners
  }
}

extension SafeListGetter<T> on List<T>{
  T getOrNull(int index) => this != null && index < this.length ? this[index] : null;  
}

void main(){
  var point1 = PointClass(1, 2);
  var point2 = PointClass(1, 2);
  print(point1);
  print(point1 == point2);
  
  var constPoint1 = const ConstPointClass(1, 2);
  var constPoint2 = const ConstPointClass(1, 2);
  print(constPoint1);
  print(constPoint1 == constPoint2);
  
  var vector1 = VectorClass(1, 2);
  var vector2 = VectorClass(1, 2);
  print(vector1);
  print(vector1 == vector2);
  print(vector1 + vector2);
  vector1 += vector2;
  
  var color = Colors.BLUE;
  print(color.index);
  print(color);
  
  var messageHolder = MessageHolder("Hello World!");
  messageHolder.phoneMyMessage();
  
  var extendedMessageHolder = ExtendedMessageHolder("Hello", "Tuesday");
  extendedMessageHolder.phoneMyMessage();
  print(extendedMessageHolder.receiveMessage());
  
  List<int> myList;
  print(myList.getOrNull(4));
}
```
